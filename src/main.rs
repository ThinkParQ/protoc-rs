use clap::{Parser, Subcommand};
use std::io::Write;
use std::path::{Path, PathBuf};

/// Protobuf / gRPC Rust code generator
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct CmdArgs {
    #[command(subcommand)]
    mode: Mode,
}

#[derive(Debug, Subcommand)]
enum Mode {
    Compile(Compile),
}

/// Compiles .proto files into Rust
#[derive(Parser, Debug)]
struct Compile {
    /// The .proto files to compile.
    ///
    /// The base paths must be literally the same as one of the given
    /// include dirs, otherwise compilation will fail. Interchanging absolute and relative
    /// paths is not allowed.
    proto_file: Vec<PathBuf>,
    /// Protobuf include dirs
    #[arg(long, short = 'I')]
    include: Vec<PathBuf>,
    /// The output directory for the compiled protobuf files
    #[arg(long)]
    out: PathBuf,
}

fn main() {
    let args = CmdArgs::parse();

    match args.mode {
        Mode::Compile(ref args) => compile_protos(args),
    }
}

/// Compiles .proto files into Rust
fn compile_protos(args: &Compile) {
    std::fs::create_dir_all(&args.out).ok();

    tonic_build::configure()
        .out_dir(&args.out)
        .compile(&args.proto_file, &args.include)
        .unwrap();

    generate_lib(&args.out, true);
}

/// Generates the necessary modules files in the Rust protobuf file structure to be able
/// to build the generated crate and use it as a library.
fn generate_lib(src: impl AsRef<Path>, root: bool) {
    let mut mod_file = std::fs::File::options()
        .create(true)
        .write(true)
        .truncate(true)
        .open(src.as_ref().join(if root { "lib.rs" } else { "mod.rs" }))
        .unwrap();

    write!(mod_file, "// Auto-generated by protoc-rs\n\n").unwrap();

    let mut entries: Vec<_> = std::fs::read_dir(&src)
        .unwrap()
        .map(|e| e.unwrap())
        .collect();

    // Sort the entries manually to ensure same order on different systems
    entries.sort_by_key(|e| e.file_name());

    for e in entries {
        let path = e.path();

        if path.is_dir() {
            generate_lib(&path, false);
        }

        if path.is_dir()
            || (path.is_file()
                && path.extension().unwrap() == "rs"
                && !&["lib.rs", "mod.rs"].contains(&path.file_name().unwrap().to_str().unwrap()))
        {
            let file_stem = path.file_stem().unwrap().to_str().unwrap();

            if file_stem.contains('.') {
                panic!("\".\" in file, directory or protobuf package names is not allowed.");
            }

            writeln!(mod_file, "pub mod {file_stem};",).unwrap();
        }
    }
}
