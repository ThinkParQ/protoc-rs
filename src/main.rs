use clap::Parser;
use std::io::Write;
use std::path::{Path, PathBuf};

/// Protobuf / gRPC Rust code generator
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct CmdArgs {
    /// The .proto files to compile.
    ///
    /// The base paths must be the same as one of the given include dirs, otherwise compilation will
    /// fail. Interchanging absolute and relative paths is not allowed.
    proto_file: Vec<PathBuf>,
    /// Protobuf include dirs
    #[arg(long, short = 'I')]
    include: Vec<PathBuf>,
    /// The output directory for the compiled protobuf files
    #[arg(long)]
    out: PathBuf,
}

fn main() {
    let args = CmdArgs::parse();
    compile_protos(&args)
}

/// Compiles .proto files into Rust
fn compile_protos(args: &CmdArgs) {
    check_dep_versions();

    std::fs::create_dir_all(&args.out).ok();

    tonic_build::configure()
        .out_dir(&args.out)
        .compile_protos(&args.proto_file, &args.include)
        .unwrap();

    generate_lib(&args.out, true);
}

/// Checks that the versions of the tonic/prost dependencies set in Cargo.toml match the ones that
/// are built in and used to generate the code
fn check_dep_versions() {
    let metadata = cargo_metadata::MetadataCommand::new()
        .exec()
        .expect("Invalid cargo metadata");

    for dep in metadata
        .root_package()
        .unwrap()
        .dependencies
        .iter()
        .filter(|e| ["tonic", "prost", "prost-types"].contains(&e.name.as_str()))
    {
        if dep.req.to_string() != env!("TONIC_BUILD_VERSION") {
            panic!(
                "Dependency `{}`s version requirement ({}) does not match the builtins `tonic-build` version requirement ({})",
                dep.name,
                dep.req,
                env!("TONIC_BUILD_VERSION")
            );
        }
    }
}

/// Generates the necessary modules files in the Rust protobuf file structure to be able
/// to build the generated crate and use it as a library.
fn generate_lib(src: impl AsRef<Path>, root: bool) {
    let mut mod_file = std::fs::File::options()
        .create(true)
        .write(true)
        .truncate(true)
        .open(src.as_ref().join(if root { "lib.rs" } else { "mod.rs" }))
        .unwrap();

    write!(mod_file, "// Auto-generated by protoc-rs\n\n").unwrap();

    let mut entries: Vec<_> = std::fs::read_dir(&src)
        .unwrap()
        .map(|e| e.unwrap())
        .collect();

    // Sort the entries manually to ensure same order on different systems
    entries.sort_by_key(|e| e.file_name());

    for e in entries {
        let path = e.path();

        if path.is_dir() {
            generate_lib(&path, false);
        }

        if path.is_dir()
            || (path.is_file()
                && path.extension().is_some_and(|ext| ext == "rs")
                && !&["lib.rs", "mod.rs"].contains(&path.file_name().unwrap().to_str().unwrap()))
        {
            let file_stem = path.file_stem().unwrap().to_str().unwrap();

            if file_stem.contains('.') {
                panic!("\".\" in file, directory or protobuf package names is not allowed.");
            }

            writeln!(mod_file, "pub mod {file_stem};",).unwrap();
        }
    }
}
